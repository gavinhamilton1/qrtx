<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QR File Transfer - Fountain Codes</title>
    <script src="/public/qrcode.min.js"></script>
    <script>
        // Verify QRCode is loaded after page load
        window.addEventListener('load', function() {
            if (typeof QRCode === 'undefined') {
                console.error('QRCode library failed to load from local file');
                alert('Failed to load QR code library. Please ensure qrcode.min.js is in the public directory.');
            } else {
                console.log('QRCode library loaded successfully');
            }
        });
    </script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
            color: #333;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            padding: 40px;
        }
        
        h2 {
            text-align: center;
            color: #667eea;
            margin-bottom: 20px;
            font-size: 1.5em;
        }
        
        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 1.1em;
        }
        
        .panel {
            display: none;
        }
        
        .panel.active {
            display: block;
        }
        
        .upload-area {
            border: 3px dashed #667eea;
            border-radius: 15px;
            padding: 60px 20px;
            text-align: center;
            background: #f8f9ff;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 20px;
        }
        
        .upload-area:hover {
            background: #f0f2ff;
            border-color: #764ba2;
        }
        
        .upload-area.dragover {
            background: #e8ebff;
            border-color: #764ba2;
        }
        
        .upload-icon {
            font-size: 4em;
            margin-bottom: 20px;
        }
        
        input[type="file"] {
            display: none;
        }
        
        .btn {
            padding: 12px 24px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            transition: all 0.3s;
            margin: 10px 5px;
        }
        
        .btn:hover {
            background: #764ba2;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }
        
        .qr-container {
            text-align: center;
        }
        
        #qrcode {
            display: inline-block;
            padding: 20px;
            background: white;
            border-radius: 15px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
        }
        
        .progress-container {
            margin: 20px 0;
        }
        
        .progress-bar {
            width: 100%;
            height: 30px;
            background: #e0e0e0;
            border-radius: 15px;
            overflow: hidden;
            margin: 10px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
        }
        
        .info {
            background: #f0f2ff;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            border-left: 4px solid #667eea;
        }
        
        .status {
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            font-weight: 600;
        }
        
        .status.success {
            background: #d4edda;
            color: #155724;
        }
        
        .status.error {
            background: #f8d7da;
            color: #721c24;
        }
        
        .status.info {
            background: #d1ecf1;
            color: #0c5460;
        }
        
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h2>QR Data Transfer</h2>
        
        <!-- Sender Panel -->
        <div id="sender-panel" class="panel active">
            <!-- QR Code Container - shown after upload, positioned at top -->
            <div id="qr-container-section" class="qr-container hidden" style="margin-top: 20px;">
                <div id="qrcode"></div>
            </div>
            
            <!-- Upload Section - shown before upload -->
            <div id="upload-section" class="upload-area" onclick="document.getElementById('file-input').click()">
                <div class="upload-icon">üìÅ</div>
                <h2>Click to upload or drag & drop</h2>
                <p>Maximum file size: 50MB</p>
            </div>
            <input type="file" id="file-input" onchange="handleFileSelect(event)">
            
            <!-- Block Size Dropdown - shown before upload -->
            <div id="block-size-section" style="margin: 20px 0; text-align: center;">
                <label for="block-size" style="font-size: 0.95em; color: #666; display: block; margin-bottom: 8px;">
                    <strong>Data per QR Code:</strong>
                </label>
                <select id="block-size" style="padding: 8px 15px; border: 2px solid #667eea; border-radius: 8px; font-size: 1em; background: white; color: #333; cursor: pointer;" onchange="updateBlockSizeInfo()">
                    <option value="128">128 bytes (~200 chars) - Small QR codes</option>
                    <option value="256" >256 bytes (~415 chars) - Balanced (Recommended)</option>
                    <option value="512">512 bytes (~755 chars) - Large QR codes</option>
                    <option value="1024" selected>1024 bytes (~1,400 chars) - Very large QR codes</option>
                </select>
            </div>
            
            <!-- Controls Section - shown after upload -->
            <div id="sender-info" class="hidden">
                <div style="margin: 20px 0; text-align: center;">
                    <div style="margin: 10px 0;">
                        <label for="qr-speed" style="font-size: 0.9em; color: #666;">Cycle Speed: </label>
                        <select id="qr-speed" onchange="updateQRSpeed()" style="padding: 5px 10px; border: 2px solid #667eea; border-radius: 5px; font-size: 0.9em;">
                            <option value="50" selected>Super Fast (50ms)</option>
                            <option value="100">Very Fast (100ms)</option>
                            <option value="200">Fast (200ms)</option>
                            <option value="1000">Balanced (1s)</option>
                            <option value="2000">Comfortable (2s)</option>
                            <option value="3000">Slow (3s)</option>
                        </select>
                    </div>
                    <button class="btn" onclick="testTransfer()" id="test-transfer-btn">Test Transfer</button>
                    <button class="btn" onclick="resetSender()">Reset</button>
                    <div id="test-transfer-results" style="margin-top: 20px; display: none;">
                        <div id="test-progress" style="margin: 10px 0;"></div>
                        <div id="test-result" style="margin: 10px 0;"></div>
                    </div>
                </div>
                
                <!-- File Info Card - shown after upload, below buttons -->
                <div class="info" style="margin-top: 20px;">
                    <strong>File:</strong> <span id="file-name"></span><br>
                    <strong>Size:</strong> <span id="file-size"></span><br>
                    <strong>Block Size:</strong> <span id="block-size-display">256</span> bytes per QR code
                </div>
            </div>
        </div>
    </div>
    
    <script>
        let currentSessionId = null;
        let currentEncoder = null;
        let qrCycleInterval = null;
        let currentQRNumber = 0;
        let totalQRCodes = 0;
        let qrCycleSpeed = 50;
        let uploadData = null; // Store upload response data for test transfer
        
        function updateBlockSizeInfo() {
            const blockSize = parseInt(document.getElementById('block-size').value);
            const info = document.getElementById('block-size-info');
            const estimates = {
                128: '~200 JSON chars - Small, easy to scan QR codes',
                256: '~415 JSON chars - Balanced size and density',
                512: '~755 JSON chars - Larger, denser QR codes',
                1024: '~1,400 JSON chars - Very large, very dense QR codes'
            };
            info.textContent = estimates[blockSize] + ' | Larger = fewer total QR codes needed';
        }
        
        async function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            if (file.size > 52428800) {  // 50MB
                alert('File too large! Maximum size is 50MB.');
                return;
            }
            
            const formData = new FormData();
            formData.append('file', file);
            
            // Get selected block size
            const blockSize = parseInt(document.getElementById('block-size').value);
            console.log('Selected block size from dropdown:', blockSize);
            formData.append('block_size', blockSize.toString());
            console.log('FormData entries:', Array.from(formData.entries()).map(([k, v]) => [k, v instanceof File ? v.name : v]));
            
            try {
                const response = await fetch('/upload', {
                    method: 'POST',
                    body: formData
                });
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ detail: response.statusText }));
                    throw new Error(errorData.detail || `Server error: ${response.status}`);
                }
                
                const data = await response.json();
                currentSessionId = data.session_id;
                currentEncoder = data;
                uploadData = data; // Store for test transfer
                
                const selectedBlockSize = parseInt(document.getElementById('block-size').value);
                
                document.getElementById('file-name').textContent = file.name;
                document.getElementById('file-size').textContent = formatBytes(file.size);
                document.getElementById('block-size-display').textContent = data.block_size || selectedBlockSize;
                document.getElementById('sender-info').classList.remove('hidden');
                
                // Show QR code container and hide upload area and block size dropdown after successful upload
                document.getElementById('qr-container-section').classList.remove('hidden');
                document.getElementById('upload-section').style.display = 'none';
                document.getElementById('block-size-section').style.display = 'none';
                
                console.log('Upload response:', data);
                console.log('Selected block size:', selectedBlockSize);
                
                // Get the first droplet to determine total blocks and display first QR code
                try {
                    const firstResponse = await fetch(`/next_droplet/${currentSessionId}`);
                    const firstDroplet = await firstResponse.json();
                    console.log('First droplet:', firstDroplet);
                    console.log('Upload response data:', data);
                    totalQRCodes = firstDroplet.num_blocks || 0;
                    // Estimate: we'll need more QR codes than blocks (fountain codes)
                    // Typically need 1.1-1.5x the number of blocks for reliable reconstruction
                    totalQRCodes = Math.ceil(totalQRCodes * 1.3);
                    console.log(`Block size from response: ${data.block_size || 'MISSING'}, num_blocks: ${firstDroplet.num_blocks}, block_size from droplet: ${firstDroplet.block_size || 'MISSING'}, total QR codes: ${totalQRCodes}`);
                    if (!data.block_size) {
                        console.warn('WARNING: block_size not in upload response!');
                    }
                    currentQRNumber = 0; // Will be incremented to 1 in nextQR()
                    
                    // Display the first QR code immediately, then start cycling automatically
                    await displayQRCode(firstDroplet);
                    currentQRNumber = 1;
                    
                    // Auto-start QR code cycling
                    startQRCycle();
                } catch (error) {
                    console.error('Error getting initial droplet:', error);
                }
            } catch (error) {
                alert('Error uploading file: ' + error.message);
                console.error('Upload error:', error);
            }
        }
        
        function updateQRSpeed() {
            const speedSelect = document.getElementById('qr-speed');
            qrCycleSpeed = parseInt(speedSelect.value);
            // Restart cycle with new speed if already running
            if (qrCycleInterval) {
                stopQRCycle();
                startQRCycle();
            }
        }
        
        function startQRCycle() {
            // Clear any existing interval
            if (qrCycleInterval) {
                clearInterval(qrCycleInterval);
            }

            qrCycleInterval = setInterval(() => {
                nextQR();
            }, qrCycleSpeed);
        }
        
        function stopQRCycle() {
            if (qrCycleInterval) {
                clearInterval(qrCycleInterval);
                qrCycleInterval = null;
            }
        }
        
        // Helper function to display a QR code from a droplet object
        function displayQRCode(droplet) {
            // Check if QRCode is available
            if (typeof QRCode === 'undefined') {
                alert('QR Code library not loaded. Please refresh the page.');
                console.error('QRCode is not defined');
                return;
            }
            
            // Generate QR code from JSON string
            const qrData = JSON.stringify(droplet);
            const qrContainer = document.getElementById('qrcode');
            qrContainer.innerHTML = ''; // Clear container
            
            // Create a temporary div for the QR code
            const qrDiv = document.createElement('div');
            qrDiv.id = 'qr-temp-' + Date.now();
            qrContainer.appendChild(qrDiv);
            
            // Use QRCode constructor (this library uses constructor pattern)
            try {
                // Calculate QR code size based on data length
                // More data = denser QR code, so we might need to adjust size
                const dataLength = qrData.length;
                let qrWidth = 500;  // Increased from 300 for easier capture
                let qrHeight = 500; // Increased from 300 for easier capture
                
                // Adjust size based on data length to maintain readability
                if (dataLength > 500) {
                    qrWidth = 600;  // Increased from 400 for easier capture
                    qrHeight = 600; // Increased from 400 for easier capture
                } else if (dataLength > 300) {
                    qrWidth = 550;  // Increased from 350 for easier capture
                    qrHeight = 550; // Increased from 350 for easier capture
                }
                                
                new QRCode(qrDiv, {
                    text: qrData,
                    width: qrWidth,
                    height: qrHeight,
                    colorDark: '#000000',  // Black for better contrast
                    colorLight: '#ffffff', // White background
                    // Using level M (Medium) instead of H (High) to fit more data
                    // Level M: 15% error correction, Level H: 30% error correction
                    // Level M still provides good reliability while allowing more data
                    correctLevel: QRCode.CorrectLevel.M
                });
            } catch (error) {
                console.error('QR code generation error:', error);
                qrContainer.innerHTML = '<p style="color: red;">Error generating QR code: ' + error.message + '</p>';
            }
        }
        
        async function nextQR() {
            if (!currentSessionId) return;
            
            try {
                const response = await fetch(`/next_droplet/${currentSessionId}`);
                const droplet = await response.json();
                
                // Display the QR code
                displayQRCode(droplet);
                
                // Update counter
                currentQRNumber++;
                
                // Continue cycling indefinitely - fountain codes allow unlimited droplets
                // This ensures that if the scanner misses some QR codes, they can be rescanned
                // The counter will show "X of ~Y" where Y is the estimated minimum needed
                // but we keep cycling beyond that to allow for missed scans
            } catch (error) {
                alert('Error generating QR code: ' + error.message);
                console.error('Error:', error);
            }
        }
        
        async function testTransfer() {
            if (!currentSessionId) {
                alert('Please upload a file first');
                return;
            }
            
            const testBtn = document.getElementById('test-transfer-btn');
            const resultsDiv = document.getElementById('test-transfer-results');
            const progressDiv = document.getElementById('test-progress');
            const resultDiv = document.getElementById('test-result');
            
            // Show results area
            resultsDiv.style.display = 'block';
            testBtn.disabled = true;
            testBtn.textContent = 'Testing...';
            progressDiv.innerHTML = '<p style="color: #667eea;">Starting test transfer...</p>';
            resultDiv.innerHTML = '';
            
            try {
                // Get first droplet to initialize receiver
                const firstResponse = await fetch(`/next_droplet/${currentSessionId}`);
                const firstDroplet = await firstResponse.json();
                
                console.log('First droplet for test:', firstDroplet);
                
                // Initialize receiver
                const initResponse = await fetch('/init_receiver', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        session_id: currentSessionId,
                        num_blocks: firstDroplet.num_blocks,
                        block_size: firstDroplet.block_size || 256
                    })
                });
                await initResponse.json();
                
                // Store file metadata for the receiver session
                // The backend will use this when downloading
                if (uploadData) {
                    console.log('File metadata from upload:', {filename: uploadData.filename, content_type: uploadData.content_type});
                }
                
                progressDiv.innerHTML = '<p style="color: #667eea;">Receiver initialized. Starting transfer...</p>';
                
                // Submit first droplet
                let isComplete = false;
                let dropletsSubmitted = 0;
                // No max limit - continue until reconstruction is complete
                // Fountain codes allow unlimited droplets, so we keep going until done
                const maxIterations = 100000; // Safety limit to prevent infinite loops (very high)
                
                const submitDroplet = async (droplet) => {
                    const response = await fetch('/submit_droplet', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            session_id: currentSessionId,
                            droplet: droplet
                        })
                    });
                    return await response.json();
                };
                
                // Submit first droplet
                let result = await submitDroplet(firstDroplet);
                dropletsSubmitted++;
                isComplete = result.is_complete;
                
                progressDiv.innerHTML = `
                    <p style="color: #667eea;">Transferring... ${dropletsSubmitted} droplets submitted</p>
                    <div class="progress-bar" style="width: 100%; height: 20px; background: #e0e0e0; border-radius: 10px; margin: 10px 0;">
                        <div class="progress-fill" style="height: 100%; background: linear-gradient(90deg, #667eea, #764ba2); width: ${result.progress}%; transition: width 0.3s; display: flex; align-items: center; justify-content: center; color: white; font-weight: 600; font-size: 0.8em;">${Math.round(result.progress)}%</div>
                    </div>
                `;
                
                // Continue submitting droplets until complete (no max limit)
                while (!isComplete && dropletsSubmitted < maxIterations) {
                    // Get next droplet
                    const dropletResponse = await fetch(`/next_droplet/${currentSessionId}`);
                    const droplet = await dropletResponse.json();
                    
                    // Submit it
                    result = await submitDroplet(droplet);
                    dropletsSubmitted++;
                    isComplete = result.is_complete;
                    
                    // Update progress
                    progressDiv.innerHTML = `
                        <p style="color: #667eea;">Transferring... ${dropletsSubmitted} droplets submitted</p>
                        <div class="progress-bar" style="width: 100%; height: 20px; background: #e0e0e0; border-radius: 10px; margin: 10px 0;">
                            <div class="progress-fill" style="height: 100%; background: linear-gradient(90deg, #667eea, #764ba2); width: ${result.progress}%; transition: width 0.3s; display: flex; align-items: center; justify-content: center; color: white; font-weight: 600; font-size: 0.8em;">${Math.round(result.progress)}%</div>
                        </div>
                    `;
                    
                    // Small delay to make it visible
                    await new Promise(resolve => setTimeout(resolve, 50));
                }
                
                if (isComplete) {
                    progressDiv.innerHTML = '<p style="color: #28a745; font-weight: 600;">‚úÖ Transfer complete!</p>';
                    
                    // Download the reconstructed file
                    const downloadResponse = await fetch(`/download/${currentSessionId}`);
                    const blob = await downloadResponse.blob();
                    
                    // Get original filename from upload response if available
                    const originalFilename = (uploadData && uploadData.filename) || 'reconstructed_file.bin';
                    const fileSize = blob.size;
                    const fileType = blob.type || (uploadData && uploadData.content_type) || 'application/octet-stream';
                    
                    // Create download link with original filename
                    const blobUrl = URL.createObjectURL(blob);
                    const downloadLink = document.createElement('a');
                    downloadLink.href = blobUrl;
                    downloadLink.download = originalFilename;
                    downloadLink.className = 'btn';
                    downloadLink.style.cssText = 'margin-top: 10px; display: inline-block;';
                    downloadLink.textContent = `Download ${originalFilename}`;
                    
                    resultDiv.innerHTML = `
                        <div style="background: #d4edda; padding: 15px; border-radius: 10px; border-left: 4px solid #28a745;">
                            <h4 style="color: #155724; margin-bottom: 10px;">‚úÖ File Reconstructed Successfully!</h4>
                            <p><strong>Filename:</strong> ${originalFilename}</p>
                            <p><strong>Size:</strong> ${formatBytes(fileSize)}</p>
                            <p><strong>Type:</strong> ${fileType}</p>
                            <p><strong>Droplets used:</strong> ${dropletsSubmitted}</p>
                        </div>
                    `;
                    resultDiv.appendChild(downloadLink);
                } else if (dropletsSubmitted >= maxIterations) {
                    progressDiv.innerHTML = '<p style="color: #dc3545;">‚ö†Ô∏è Safety limit reached</p>';
                    resultDiv.innerHTML = '<p style="color: #721c24;">Reached safety iteration limit. This might indicate an issue with the fountain code implementation. Progress: ' + Math.round(result.progress) + '%</p>';
                } else {
                    progressDiv.innerHTML = '<p style="color: #dc3545;">‚ö†Ô∏è Transfer incomplete</p>';
                    resultDiv.innerHTML = '<p style="color: #721c24;">The file could not be fully reconstructed. Progress: ' + Math.round(result.progress) + '%. This might indicate an issue with the fountain code implementation.</p>';
                }
            } catch (error) {
                console.error('Test transfer error:', error);
                progressDiv.innerHTML = `<p style="color: #dc3545;">‚ùå Error: ${error.message}</p>`;
                resultDiv.innerHTML = `<p style="color: #721c24;">${error.message}</p>`;
            } finally {
                testBtn.disabled = false;
                testBtn.textContent = 'Test Transfer';
            }
        }
        
        function resetSender() {
            stopQRCycle();
            currentSessionId = null;
            currentEncoder = null;
            uploadData = null; // Clear upload data
            currentQRNumber = 0;
            totalQRCodes = 0;
            document.getElementById('sender-info').classList.add('hidden');
            document.getElementById('file-input').value = '';
            document.getElementById('qrcode').innerHTML = '';
            document.getElementById('test-transfer-results').style.display = 'none';
            
            // Hide QR code container and show upload area and block size dropdown again
            document.getElementById('qr-container-section').classList.add('hidden');
            document.getElementById('upload-section').style.display = 'block';
            document.getElementById('block-size-section').style.display = 'block';
        }
        
        function formatBytes(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
        }
        
        // Drag and drop support
        const uploadArea = document.getElementById('upload-section');
        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });
        
        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('dragover');
        });
        
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file) {
                const input = document.getElementById('file-input');
                const dataTransfer = new DataTransfer();
                dataTransfer.items.add(file);
                input.files = dataTransfer.files;
                handleFileSelect({ target: input });
            }
        });
    </script>
</body>
</html>

